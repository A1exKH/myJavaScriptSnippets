#include <iostream>
#include <stdlib.h>
using namespace std;

/*
Task5
Создать в производном классе метод Run, определяющий:
14. Значение (x1-x2)/y

Общая постановка. Программа должна содержать:

базовый класс Х, включающий два  элемента х1, х2 типа int,

конструктор с параметрами для создания объектов в динамической области памяти,

деструктор,

виртуальные методы просмотра текущего состояния и переустановки объектов базового класса в новое состояние.

производный класс У, включающий один элемент у типа int ,

конструктор с параметрами и  списком инициализаторов, передающий данные конструктору базового класса,

переопределенные методы просмотра текущего состояния объектов и их переустановки в новое состояние.
*/

//Объявляем базовый класс
class X
{
    // раздел того, что будет доступно детям, но невидно извне.
    protected:
        int *x1, *x2; // 2 поля с динамическим хранением

    // раздел того, что доступно всем, в т.ч. извне.
    public:

        // конструктор с параметрами, обычная инициализация
        X(int a, int b)
        {
            // просим память под переменные
            x1 = new int;
            x2 = new int;
            // записываем в них собсно значения
            *x1 = a;
            *x2 = b;
        }

        // виртуальная функция просмотра текущего состояния базового класса
        virtual void view()
        {
            cout << "x1=" << *x1 << " x2=" << *x2 << endl;
        }

        // виртуальная функция установки состояния базового класса в новое значение
        virtual void set_new()
        {
            // читаем новые значения х1, х2 с консоли
            int i;
            cout << "Input x1: ";
            cin >>i;
            *x1 = i;
            cout << "Input x2: ";
            cin >> i;
            *x2 = i;
            getchar();

        }

        // деструктор базового класса
        ~X()
        {
            // старательно чистим память, которую просили в конструкторе
            delete x1;
            delete x2;
        }
};

// производный класс У, унаследованный от Х.
class Y:public X
{
    private:
        int *y; //аналогично, тока раз детей у класса У не будет, спрячем поле как прайвет.

    public:

        // конструктор с инициализацией списком.
        Y(int a, int b, int c):X(a,b) // вот тут дернули конструктор базового класса Х(a,b) передав туда параметры - чтобы записалось х1, х2
        {
            // уже знакомым способом просим память и заполняем значением новую переменную этого класса
            y = new int;
            *y = c;
        }

        // переопределенный метод просмотра текущего состояния объекта. Поля-то у нас 3 теперь, надо выводить их все.
        virtual void view()
        {
            // х1, х2 тут доступны, т.к. они protected в Х, а значит унаследовались от базового класса.
            cout << "x1=" << *x1 << " x2=" << *x2 << " y=" << *y << endl;
        }

        // переопределенный метод установки нового значения. Опять-таки, поля у нас аж 3, и снова х1, х2 видны тут.
        virtual void set_new()
        {
            cout << "Input x1: ";
            cin >> *x1;
            cout << "Input x2: ";
            cin >> *x2;
            cout << "Input y: ";
            cin >> *y;
            getchar();
        }

        // деструктор класса У. в нем очищаем память, которую просили в конструкторе.
        ~Y()
        {
            delete y;
        }

        // собсно, метод что-то вычисляющий и выводящий значение на консоль.
        void Run()
        {
            cout << "Res: " << ( *x1 - *x2 ) / *y << endl;
        }
};

int main()
{
    X *t; // объявили указатель на базовый класс.
    t = new X(10,20); // создали новый объект Х[х1=10, х2=20]
    t->view(); // дернули у объекта метод просмотра. Получим "х1=10 х2=20"
    t->set_new(); // запишем в него чет новое, вызвав метод установки новых значений.
    t->view(); // дернули опять просмотр. Получим то, что ввели на предыдущем шаге.

    delete t; // удалим объект класса Х, тут у него дернулся дестркутор ~X(), и память освободилась

    t = new Y(100, 50, 2); // создадим экземпляр класса У[x1=100, x2=50, y=2], но указывать на него будет все тот же указатель.
    t->view(); //дернули у него метод просмотра. Вот тут сработала виртуализация, и мы получили не "х1=100 х2=50" а "х1=100 х2=50 у=2"
    t->set_new(); // аналогичным образом простаавим новые значения. сработает виртуализация, и нас спросят не про 2 параметра, а уже про 3.
    t->view(); // посмотрим, что же мы там ввели в этот игрэк.

    // танцы с бубном: просто вызвать метод Run() типа так: t->Run(); мы не можем, т.к. у класса Х этого метода нет,
    // он есть только у класса Y. Поэтому сначала преобразуем тип указателя к типу Y* сделав ((Y*) t),
    // а потом у уже полученного таким образом указателя Y* вызовем метод Run().
    // А если бы было:
    // Y* p = new Y(1,2,3);
    // то можно бы было вызвать сразу
    // p->Run();
    ((Y*) t)->Run();

    getchar();
    return 0;
}
