#include <iostream>
#include <stdlib.h>
using namespace std;

/*
Task5
Создать в производном классе метод Run, определяющий:
14. Значение (x1-x2)/y

Общая постановка. Программа должна содержать:

базовый класс Х, включающий два  элемента х1, х2 типа int,

конструктор с параметрами для создания объектов в динамической области памяти,

деструктор,

виртуальные методы просмотра текущего состояния и переустановки объектов базового класса в новое состояние.

производный класс У, включающий один элемент у типа int ,

конструктор с параметрами и  списком инициализаторов, передающий данные конструктору базового класса,

переопределенные методы просмотра текущего состояния объектов и их переустановки в новое состояние.
*/

//базовый класс
class A{

    protected:
        int *x1, *x2;

    public:

        A(int X1, int X2){
            x1 = new int;
            x2 = new int;
            *x1 = X1;
            *x2 = X2;
        }

        virtual void print(){
            cout << "x1=" << *x1 << " x2=" << *x2 <<endl;
        }

        virtual void set_new(){
            cout << "Enter x1: ";
            cin >> *x1;
            cout << "Enter x2: ";
            cin >> *x2;
            getchar();

        }

        ~A(){
            delete x1;
            delete x2;
        }
};

class B:public A{
    private:
        int *y;

    public:

        // конструктор с инициализацией списком.
        // вот тут дернули конструктор базового класса A(a,b) передав туда параметры - чтобы записалось х1, х2
        B(int X1, int X2, int Y):A(X1,X2){
            // уже знакомым способом просим память и заполняем значением новую переменную этого класса
            y = new int;
            *y = Y;
        }

        // переопределенный метод просмотра текущего состояния объекта. Поля-то у нас 3 теперь, надо выводить их все.
        virtual void print(){
            // х1, х2 тут доступны, т.к. они protected в A, а значит унаследовались от базового класса.
            cout << "x1=" << *x1 << " x2=" << *x2 << " y=" << *y << endl;
        }

        // переопределенный метод установки нового значения. Опять-таки, поля у нас аж 3, и снова х1, х2 видны тут.
        virtual void set_new(){
            cout << "Enter x1: ";
            cin >> *x1;
            cout << "Enter x2: ";
            cin >> *x2;
            cout << "Enter y: ";
            cin >> *y;
            getchar();
        }

        ~B(){
            delete y;
        }

        void run(){
            cout << "(x1-x2)/y = " << ( *x1 - *x2 ) / *y << endl;
        }
};

int main(){
    A *myInstance;
    myInstance = new A(1,2);
    myInstance->print();
    myInstance->set_new();
    myInstance->print();

    myInstance->~A();

    myInstance = new B(3, 4, 5); // создадим экземпляр класса A[x1=3, x2=4, y=5], но указывать на него будет все тот же указатель.
    myInstance->print(); //дернули у него метод просмотра. Вот тут сработала виртуализация, и мы получили не "х1=100 х2=50" а "х1=100 х2=50 у=2"
    myInstance->set_new(); // аналогичным образом простаавим новые значения. сработает виртуализация, и нас спросят не про 2 параметра, а уже про 3.
    myInstance->print(); // посмотрим, что же мы там ввели в этот игрэк.

    // танцы с бубном: просто вызвать метод run() типа так: myInstance->run(); мы не можем, т.к. у класса A этого метода нет,
    // он есть только у класса Y. Поэтому сначала преобразуем тип указателя к типу B* сделав ((B*) myInstance),
    // а потом у уже полученного таким образом указателя B* вызовем метод Run().
    // А если бы было:
    // B* p = new B(1,2,3);
    // то можно бы было вызвать сразу
    // p->run();
    ((B*) myInstance)->run();

    myInstance->~A();

    getchar();
    return 0;
}
